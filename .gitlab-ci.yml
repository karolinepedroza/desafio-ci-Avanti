# Define a imagem Docker padrão para todos os jobs da pipeline
default:
  image: golang:1.24-alpine

# Define os estágios da pipeline. Os jobs são executados na ordem dos estágios.
stages:
  - build-lint
  - test
  - release
  - deploy

variables:
  DOCKER_USER: taotreinatec
  DOCKER_PASS: $DOCKER_PASS
  DOCKER_IMAGE_NAME: $DOCKER_USER/ms-saudacoes-aleatorias
  DOCKER_REGISTRY: registry.hub.docker.com
  DOCKER_IMAGE_TAG: 1.0.$CI_PIPELINE_IID
  RENDER_OWNER_ID: $RENDER_OWNER_ID
  RENDER_API_KEY: $RENDER_API_KEY
  SERVICE_NAME: saudacoes-aleatorias
  COOLIFY_TOKEN: $COOLIFY_TOKEN
  NOME_ALUNO: "Thiago Augusto Ozores"

# Job para verificar formatação e erros comuns no código Go
lint-code:
  stage: build-lint
  script:
    - echo "Linting code..."
    - go fmt $(go list ./...)
    - go vet $(go list ./...)
  rules:
    - if: $CI_COMMIT_BRANCH != "main"
      when: always

golangci-lint:
  stage: build-lint
  # Usa a imagem oficial do golangci-lint.
  image: golangci/golangci-lint:v2.2-alpine
  script:
    - echo "Executando linter no código..."
    # Executa o linter. O cache é limpo para garantir uma verificação completa.
    - golangci-lint run --verbose
  rules:
    - if: $CI_COMMIT_BRANCH != "main"
      when: always

run-tests:
  stage: test
  script:
    - echo "Rodando testes e gerando report..."
    - apk add --no-cache build-base gcc
    - go install gotest.tools/gotestsum@latest
    - CGO_ENABLED=1 gotestsum --junitfile report.xml --format testname
  artifacts:
    when: always
    reports:
      junit: report.xml
  rules:
    - if: $CI_COMMIT_BRANCH != "main"
      when: always

# Job para construir a imagem Docker e enviá-la para o Docker Hub
build-and-push-image:
  stage: release
  tags:
    - gitlab-org-docker # Certifique-se que este runner suporta modo privilegiado
  # É recomendado usar uma imagem mais recente, se possível, para ter as últimas versões do buildx
  image: docker:25.0
  services:
    - name: docker:25.0-dind
      command: ["--experimental"] # Necessário para buildx em algumas configurações
  variables:
    # Habilita o driver overlay2 para o dind, geralmente mais estável
    DOCKER_DRIVER: overlay2
    # Desativa o TLS, pois estamos nos conectando ao dind no mesmo host
    DOCKER_TLS_CERTDIR: ""
    # Define as plataformas alvo
    PLATFORMS: "linux/amd64,linux/arm64"
  before_script:
    # 1. Login no Docker Hub
    - echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin
    
    # 2. Habilita a emulação de outras arquiteturas via QEMU
    # O buildx usará o QEMU para construir a imagem ARM em um runner AMD64
    - docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
    
    # 3. Cria e utiliza um novo builder buildx
    # Isso cria uma instância de builder que pode lidar com múltiplas plataformas
    - docker buildx create --use --name multi-platform-builder
    - docker buildx inspect --bootstrap

  script:
    - echo "Construindo e enviando a imagem multi-plataforma..."
    # 4. Constrói e envia a imagem para todas as plataformas de uma só vez
    # O --push é crucial: ele envia o resultado diretamente para o registry
    # O buildx cria um "manifest list" no Docker Hub que aponta para as imagens de cada arquitetura
    - docker buildx build --platform "$PLATFORMS" --tag "$DOCKER_IMAGE_NAME:$DOCKER_IMAGE_TAG" --tag "$DOCKER_IMAGE_NAME:latest" --push .

  only:
    - main

# Job para acionar o deploy no Render
deploy-to-staging:
  stage: deploy
  image:
    name: hashicorp/terraform:latest
    entrypoint:
      - '/usr/bin/env'
      - 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  variables:
    TF_VAR_docker_image_name: $DOCKER_IMAGE_NAME
    TF_VAR_docker_image_tag: $DOCKER_IMAGE_TAG
    TF_VAR_coolify_token: $COOLIFY_TOKEN
    TF_VAR_nome_aluno: $NOME_ALUNO
  before_script:
    - cd infra
    - terraform init
    - terraform validate
  script:
    - terraform apply -auto-approve
    - echo "UUID=$(terraform output -raw uuid)" >> build.env
  artifacts:
    reports:
      dotenv: build.env
  only:
    - main

start-app:
  stage: deploy
  image: curlimages/curl
  script:
    - export APP_UUID=$(cat build.env | grep UUID | cut -d= -f2)
    - curl "https://coolify.tao.tec.br/api/v1/applications/$APP_UUID/start?force=true&instant_deploy=true" --header "Authorization: Bearer $COOLIFY_TOKEN"
  only:
    - main
  
